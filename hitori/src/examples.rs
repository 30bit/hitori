//! Structs and trait implementations generated by
//! [`impl_expr`] and [`impl_expr_mut`] along with the source code.
//!
//! # All-patterns
//!
//! Sequences of subpatterns can be matched using an all-pattern.
//! In [hitori] syntax it is represented as a tuple of its subpatterns.
//!
//! ```
#![doc = include_example!("hello")]
//! ```
//! *equivalent to `hello` in [regex] syntax*
//!
//! ### Trailing comma
//!
//! The only way to apply attributes such as `#[hitori::capture]` or
//! `#[hitori::repeat]` to a single character test is by wrapping it
//! inside of an all-pattern. In that case trailing comma
//! is **not** optional.
//!
//! ```
#![doc = include_example!("aaaaa")]
//! ```
//! *equivalent to `a{5}` in [regex] syntax*
//!
//! ### Empty all-pattern
//!
//! An empty all-pattern is always true.
//!
//! ```
#![doc = include_example!("true_")]
//! ```
//!
//! # Any-pattens
//!
//! An any-pattern matches if one of its subpatterns matches.
//! In [hitori] syntax it is represented as an array of its subpatterns.
//!
//! ```
#![doc = include_example!("float_type")]
//! ```
//! *equivalent to `f(32|64)` in [regex] syntax*
//!
//! ### Empty any-pattern
//!
//! An empty any-pattern is always false.
//!
//! ```
#![doc = include_example!("false_")]
//! ```
//!
//! # Capturing
//!
//! Capturing is done by annotating an all-pattern or an any-pattern with
//! `#[hitori::capture]`. Captured index ranges are returned
//! as fields of [`ExprMut::Capture`] struct that is generated by the macro.
//! The name of the struct is a concatenation of implementor's name and
//! `Capture` by default.
//!
//! ```
#![doc = include_example!("fraction")]
//! ```
//! *equivalent to `(?P<numerator>\d)/(?P<denominator>[1-9])` in [regex] syntax*
//!
//! ### Reused capture names
//!
//! Unlike in [regex], non-unique capture names are allowed. The last capture into
//! the same destination is the one that is returned in [`ExprMut::Capture`] struct.
//!
//! ```
#![doc = include_example!("shopping_list")]
//! ```
//! *equivalent to `(?P<last_item>üçÑ)?(?P<last_item>ü´ë)?(?P<last_item>üßÄ)?(?P<last_item>ü•ö)?`
//! in [regex] syntax*
//!
//! ### Multiple destinations
//!
//! An expression can be captured into multiple destinations using
//! `#[hitori::capture(dest1, dest2, dest3)]` syntax.
//!
//! ```
#![doc = include_example!("rectangle")]
//! ```
//! *equivalent to `‚óæ (?P<width>(?P<height>\d))|‚ñ¨ (?P<width>\d) (?P<height>\d)`
//! in [regex] syntax*
//!
//! # Repetitions
//!
//! Repetition is done by annotating an all-pattern or an any-pattern with
//! `#[hitori::repeat]`. There are 5 possible name-value arguments:
//!
//! - **`eq = x`** ‚Äì exactly `x` times
//! - **`lt = x`** ‚Äì less than `x` times.
//! - **`le = x`** ‚Äì less or equal to `x` times.
//! - **`gt = x`** ‚Äì greater than `x` times.
//! - **`ge = x`** ‚Äì greater or equal to `x` times.
//!
//! Value assigned to any bound must be either literal
//! [`usize`] (like `lt = 410` or `gt = 20usize`)
//! or literal string containing an expression that evaluates to
//! [`usize`] (like `eq = "self.name.len()"`).
//!
//! ```
#![doc = include_example!("identifier")]
//! ```
//!
//! # Combining bounds
//!
//! Lower bounds (`gt` and `ge`) can be combined with upper bounds  (`lt` and `le`).
//! Default lower bound is `ge = 0`, while an upper bound is unbounded by default.
//!
//! ```
#![doc = include_example!("binary_u32")]
//! ```
//!
//! # Expression bounds
//!
//! Expression bounds can be used repeat `x` times, where `x` is not a literal int
//! (e.g. as constant names or [`ExprMut`] implementor's fields).
//!
#![doc = include_example!("would_you_kindly")]
//!
//! [`impl_expr`]: crate::impl_expr
//! [`impl_expr_mut`]: crate::impl_expr
//! [hitori]: https://docs.rs/hitori
//! [regex]: https://docs.rs/regex
//! [`ExprMut::Capture`]: crate::ExprMut::Capture
//![`ExprMut`]: crate::ExprMut

mod aaaaa;
mod binary_u32;
mod false_;
mod float_type;
mod fraction;
mod hello;
mod identifier;
mod rectangle;
mod shopping_list;
mod true_;
mod would_you_kindly;

macro_rules! include_example {
    ($name:literal) => {
        concat!("# //", include_str!(concat!("examples/", $name, ".rs")))
    };
}

pub(self) use include_example;
