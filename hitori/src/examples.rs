//! Structs and trait implementations generated by
//! [`impl_expr`] and [`impl_expr_mut`] along with the source code.
//!
//! # All-patterns
//!
//! Sequences of subpatterns can be matched using an all-pattern.
//! In [hitori] syntax it is represented as a tuple of its subpatterns.
//!
//! ```
#![doc = include_example!("hello")]
//!
//! assert!(hitori::string::matches(Hello, "hello").is_some());
//! assert!(hitori::string::matches(Hello, "world").is_none());
//! ```
//! *equivalent to `hello` in [regex] syntax*
//!
//! ### Trailing comma
//!
//! The only way to apply attributes such as `#[hitori::capture]` or
//! `#[hitori::repeat]` to a single character test is by wrapping it
//! inside of an all-pattern. In that case trailing comma
//! is **not** optional.
//!
//! ```
#![doc = include_example!("bad_password")]
//!
//! assert!(hitori::string::matches(BadPassword, "12345").is_some());
//! assert!(hitori::string::matches(BadPassword, "cUFK^06#43Gs").is_none());
//! ```
//! *equivalent to `\d{1, 8}` in [regex] syntax*
//!
//! ### Empty all-pattern
//!
//! An empty all-pattern is always true.
//!
//! ```
#![doc = include_example!("true_")]
//!
//! for s in ["Hello, world!", "34", "hitori"] {
//!     assert!(hitori::string::matches(True, s).is_some());
//! }
//! ```
//!
//! # Any-pattens
//!
//! An any-pattern matches if one of its subpatterns matches.
//! In [hitori] syntax it is represented as an array of its subpatterns.
//!
//! ```
#![doc = include_example!("float_type")]
//!
//! assert!(hitori::string::matches(FloatType, "f64").is_some());
//! assert!(hitori::string::matches(FloatType, "f128").is_none());
//! ```
//! *equivalent to `f(32|64)` in [regex] syntax*
//!
//! ### Empty any-pattern
//!
//! An empty any-pattern is always false.
//!
//! ```
#![doc = include_example!("false_")]
//!
//! for s in ["Hello, world!", "34", "hitori"] {
//!     assert!(hitori::string::matches(False, s).is_none());
//! }
//! ```
//!
//! # Capturing
//!
//! Capturing is done by annotating an all-pattern or an any-pattern with
//! `#[hitori::capture]`. Captured index ranges are returned
//! as fields of [`ExprMut::Capture`] struct that is generated by the macro.
//! The name of the struct is a concatenation of implementor's name and
//! `Capture` by default.
//!
//! ```
#![doc = include_example!("fraction")]
//!
//! let s = "4/5";
//! let matched = hitori::string::matches(Fraction, s).unwrap();
//! assert_eq!(&s[matched.capture.numerator.unwrap()], "4");
//! assert_eq!(&s[matched.capture.denominator.unwrap()], "5");
//!
//! assert!(hitori::string::matches(Fraction, "1/0").is_none());
//! ```
//! *equivalent to `(?P<numerator>\d)/(?P<denominator>[1-9])` in [regex] syntax*
//!
//! ### Reused capture names
//!
//! Unlike in [regex], non-unique capture names are allowed. The last capture into
//! the same destination is the one that is returned in [`ExprMut::Capture`] struct.
//!
//! ```
#![doc = include_example!("shopping_list")]
//!
//! let s = "🍄🧀";
//! let matched = hitori::string::matches(ShoppingList, s).unwrap();
//! assert_eq!(&s[matched.capture.last_item.unwrap()], "🧀");
//! ```
//! *equivalent to `(?P<last_item>🍄)?(?P<last_item>🫑)?(?P<last_item>🧀)?(?P<last_item>🥚)?`
//! in [regex] syntax*
//!
//! ### Multiple destinations
//!
//! An expression can be captured into multiple destinations using
//! `#[hitori::capture(dest1, dest2, dest3)]` syntax.
//!
//! ```
#![doc = include_example!("rectangle")]
//!
//! let s = "◾ 9";
//! let matched = hitori::string::matches(Fraction, s).unwrap();
//! assert_eq!(&s[matched.capture.width.unwrap()], "9");
//! assert_eq!(&s[matched.capture.height.unwrap()], "9");
//!
//! let s = "▬ 5 6";
//! let matched = hitori::string::matches(Fraction, s).unwrap();
//! assert_eq!(&s[matched.capture.width.unwrap()], "5");
//! assert_eq!(&s[matched.capture.height.unwrap()], "6");
//! ```
//! *equivalent to `◾ (?P<width>(?P<height>\d))|▬ (?P<width>\d) (?P<height>\d)`
//! in [regex] syntax*
//!
//! # Repetitions
//!
//! Repetition is done by annotating an all-pattern or an any-pattern with
//! `#[hitori::repeat]`. There are 5 possible name-value arguments:
//!
//! - **`eq = x`** – exactly `x` times
//! - **`lt = x`** – less than `x` times.
//! - **`le = x`** – less or equal to `x` times.
//! - **`gt = x`** – greater than `x` times.
//! - **`ge = x`** – greater or equal to `x` times.
//!
//! Value assigned to the bound must be either literal
//! [`usize`] (like `lt = 410` or `ge = 20usize`)
//! or literal string containing an expression that evaluates to
//! [`usize`] (like `eq = "self.name.len()"`).
//!
//! ```
#![doc = include_example!("identifier")]
//!
//! for s in ["_", "x1", "my_var32"] {
//!     assert!(hitori::string::matches(Identifier, s).is_some());
//! }
//! ```
//! *equivalent to `[[:alpha:]_]\w*` in [regex] syntax*
//!
//! ### Combining bounds
//!
//! Lower bounds (`gt` and `ge`) can be combined with upper bounds  (`lt` and `le`).
//! Default lower bound is `ge = 0`, while an upper bound is unbounded by default.
//!
//! ```
#![doc = include_example!("binary_u32")]
//!
//! assert!(hitori::string::matches(BinaryU32, "0b110011010").is_some());
//! ```
//! *equivalent to `0b[01]{1,32}` in [regex] syntax*
//!
//! ### Expression bounds
//!
//! Expression bounds can be used when the number of times to repeat
//! is not a literal [`usize`] (e.g. constants, function outputs
//! and [`ExprMut`] implementor's fields and methods).
//!
//! ```
#![doc = include_example!("would_you_kindly")]
//!
//! let s = "Would you kindly lower that weapon for a moment?";
//! let matched = hitori::string::matches(WouldYouKindly::default(), s).unwrap();
//! assert_eq!(&s[matched.capture.request.unwrap()], "lower that weapon for a moment");
//!```
//! *equivalent to `Would you kindly (?P<request>[^?]+)\?` in [regex] syntax*
//!
//! # Positions
//!
//! Annotating an all-pattern or an any-pattern with `#[hitori::position]` adds
//! a check of relative to an input position of a matched subpattern. There are 2
//! possible arguments:
//!
//! - **`first`** – subpattern matched from the beginning of an input
//! - **`last`** – subpattern matched to the end of an input
//!
//! ```
#![doc = include_example!("train_cars")]
//!
//! assert!(hitori::string::matches(TrainCars, "🚃").is_some());
//! assert!(hitori::string::matches(TrainCars, "🚃🚃🚃🚃🚃").is_some());
//! assert!(hitori::string::matches(TrainCars, " 🚃").is_none());
//! assert!(hitori::string::matches(TrainCars, "🚃 ").is_none());
//! assert!(hitori::string::matches(TrainCars, "🚃🚃🚃🚃🚃 ").is_none());
//! assert!(hitori::string::matches(TrainCars, " 🚃🚃🚃🚃🚃").is_none());
//! ```
//! *equivalent to
//! `^(?P<last_car>(?P<first_car>🚃))$|^(?P<first_car1>🚃)🚃{3}(?P<last_car1>🚃)$`
//!  in [regex] syntax*
//!
//! [`impl_expr`]: crate::impl_expr
//! [`impl_expr_mut`]: crate::impl_expr
//! [hitori]: https://docs.rs/hitori
//! [regex]: https://docs.rs/regex
//! [`ExprMut::Capture`]: crate::ExprMut::Capture
//![`ExprMut`]: crate::ExprMut

mod bad_password;
mod binary_u32;
mod false_;
mod float_type;
mod fraction;
mod hello;
mod identifier;
mod rectangle;
mod shopping_list;
mod train_cars;
mod true_;
mod would_you_kindly;

pub use bad_password::{BadPasswordCapture, BadPassword};
pub use binary_u32::{BinaryU32, BinaryU32Capture};
pub use false_::{False, FalseCapture};
pub use float_type::{FloatType, FloatTypeCapture};
pub use fraction::{Fraction, FractionCapture};
pub use identifier::{Identifier, IdentifierCapture};
pub use rectangle::{Rectangle, RectangleCapture};
pub use shopping_list::{ShoppingList, ShoppingListCapture};
pub use train_cars::{TrainCars, TrainCarsCapture};
pub use true_::{True, TrueCapture};
pub use would_you_kindly::{WouldYouKindly, WouldYouKindlyCapture};

macro_rules! include_example {
    ($name:literal) => {
        concat!("# //", include_str!(concat!("examples/", $name, ".rs")))
    };
}

pub(self) use include_example;
